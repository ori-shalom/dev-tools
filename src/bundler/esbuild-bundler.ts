import { build, BuildOptions, BuildResult } from 'esbuild';
import { join, resolve } from 'path';
import { mkdirSync, existsSync, readFileSync } from 'fs';
import { Config, LambdaFunction, BuildConfig } from '../config/schema.js';

export type BundleOptions = {
  config: Config;
  functionName: string;
  functionConfig: LambdaFunction;
  workingDir: string;
};

export type BundleResult = {
  functionName: string;
  outputPath: string;
  size: number;
  dependencies: string[];
  warnings: string[];
};

export class ESBuildBundler {
  constructor(private buildConfig: BuildConfig) {}

  async bundleFunction(options: BundleOptions): Promise<BundleResult> {
    const { functionName, functionConfig, workingDir } = options;

    // Resolve handler path
    const handlerPath = this.resolveHandlerPath(functionConfig.handler, workingDir);
    if (!existsSync(handlerPath)) {
      throw new Error(`Handler file not found: ${handlerPath}`);
    }

    // Create output directory
    const outputDir = resolve(workingDir, this.buildConfig.outDir, functionName);
    mkdirSync(outputDir, { recursive: true });

    // Build with esbuild
    const buildResult = await this.buildWithESBuild(handlerPath, outputDir);

    // Get bundle size
    const outputPath = join(outputDir, 'index.js');
    const size = existsSync(outputPath) ? readFileSync(outputPath).length : 0;

    // Extract warnings
    const warnings = buildResult.warnings.map(
      (w) => `${w.location?.file}:${w.location?.line}:${w.location?.column}: ${w.text}`,
    );

    return {
      functionName,
      outputPath: outputDir,
      size,
      dependencies: await this.extractDependencies(outputPath),
      warnings,
    };
  }

  private resolveHandlerPath(handler: string, workingDir: string): string {
    // Handler format: path/to/file.exportName
    const [filePath] = handler.split('.');

    // Try different extensions
    const extensions = ['.ts', '.js', '.mts', '.mjs'];
    for (const ext of extensions) {
      const fullPath = resolve(workingDir, filePath + ext);
      if (existsSync(fullPath)) {
        return fullPath;
      }
    }

    // If no extension found, try the path as-is
    const fullPath = resolve(workingDir, filePath);
    if (existsSync(fullPath)) {
      return fullPath;
    }

    throw new Error(`Handler file not found: ${filePath} (tried extensions: ${extensions.join(', ')})`);
  }

  private async buildWithESBuild(entryPoint: string, outputDir: string): Promise<BuildResult> {
    const buildOptions: BuildOptions = {
      entryPoints: [entryPoint],
      bundle: true,
      platform: 'node',
      target: this.buildConfig.target,
      format: 'cjs',
      outdir: outputDir,
      outExtension: { '.js': '.js' },
      minify: this.buildConfig.minify,
      sourcemap: this.buildConfig.sourcemap,
      external: this.buildConfig.external,
      metafile: true,
      allowOverwrite: true,

      // Node.js specific options
      mainFields: ['main', 'module'],
      conditions: ['node'],

      // Lambda specific optimizations
      treeShaking: true,
      keepNames: false,

      // Resolve TypeScript and modern JS
      loader: {
        '.ts': 'ts',
        '.tsx': 'tsx',
        '.js': 'js',
        '.jsx': 'jsx',
        '.mjs': 'js',
      },

      // Handle dynamic imports
      splitting: false,

      // Banner to ensure proper Lambda handler export
      banner: {
        js: '// Generated by lambda-dev-tools',
      },
    };

    try {
      const result = await build(buildOptions);
      return result;
    } catch (error) {
      if (error instanceof Error) {
        throw new Error(`ESBuild failed: ${error.message}`);
      }
      throw error;
    }
  }

  private async extractDependencies(outputPath: string): Promise<string[]> {
    // This is a simple implementation - in a real scenario, you might want to
    // parse the metafile to get accurate dependency information
    try {
      const content = readFileSync(outputPath, 'utf8');
      const dependencies = new Set<string>();

      // Look for require() calls (simplified regex)
      const requireRegex = /require\(['"`]([^'"`]+)['"`]\)/g;
      let match;
      while ((match = requireRegex.exec(content)) !== null) {
        const dep = match[1];
        if (!dep.startsWith('.') && !dep.startsWith('/')) {
          dependencies.add(dep);
        }
      }

      return Array.from(dependencies);
    } catch {
      return [];
    }
  }

  async bundleAll(config: Config, workingDir: string): Promise<BundleResult[]> {
    const results: BundleResult[] = [];

    for (const [functionName, functionConfig] of Object.entries(config.functions)) {
      try {
        console.log(`Bundling function: ${functionName}`);
        const result = await this.bundleFunction({
          config,
          functionName,
          functionConfig,
          workingDir,
        });

        results.push(result);
        console.log(`✓ ${functionName} bundled (${this.formatBytes(result.size)})`);

        if (result.warnings.length > 0) {
          console.warn(`Warnings for ${functionName}:`);
          result.warnings.forEach((warning) => console.warn(`  ${warning}`));
        }
      } catch (error) {
        console.error(`✗ Failed to bundle ${functionName}:`, error instanceof Error ? error.message : error);
        throw error;
      }
    }

    return results;
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }
}
